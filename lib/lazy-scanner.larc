
Lazy Scanners
=============

A lazy scanner is a list structure which is lazy, i.e. the
expressions which make up its `car` and `cdr` are not evaluated
until they are actually needed.  This allows them to be used for
a variety of things; for example, they can be used to represent
an infinite list.

    (in-package lazy-scanner)
    (using <arc>v3)

`lazy-scanner.larc` needs Arc3F.

    (using <arc>v3-scanner)

Because it is a scanner, it has to overload `scanner`, `unscan`,
`car`, and `cdr`.  Using the Arc3F scanner interface allows us to
overload `scanner` and `unscan`.

This version presents the version 1 interface:

    (interface v1
      lazy-scanner lazy-destruct
      generate)

`lazy-scanner` accepts two expressions, while `lazy-destruct`
accepts a single expression which should return a `cons` cell or
other scanner.

`generate` creates an infinite list by applying a function to a
value, and repeating this application indefinitely.
    
Minor Internal Function
-----------------------

`delay` below is an internal function which creates a "thunk"
that simply returns the given value.  We use thunks to represent
the expressions that will still be expanded.

    (def delay (v)
      (fn () v))

Scanner overloads
-----------------

Scanner types should, at the minimum, provide the `car`, `cdr`,
`scanner`, and `unscan`.  They may also overload `<base>each` and
`<base>collect-on`.

    (defm car ((t x lazy-scanner-type))
      ((car (rep x))))

The representation of a `lazy-scanner` is in fact just a simple
`cons` cell.  This `cons` cell contains two thunks, one for the
`car` of the lazy scanner and another for the `cdr`.

The thunks themselves are responsible for the laziness; once
they have computed the "correct" result, they will replace
themselves with thunks generated by `delay` above.  This lowers
the dispatch overhead for `car` and `cdr`

    (defm cdr ((t x lazy-scanner-type))
      ((cdr (rep x))))

Like any scanner, lazy scanners simply pass the object through
in `scanner` and `unscan`.

    (defm scanner ((t x lazy-scanner-type))
      x)
    (defm unscan ((t orig lazy-scanner-type) x)
      x)


Creating lazy scanners with `lazy-scanner`
------------------------------------------

The `lazy-scanner` form creates a scanner whose `car` and `cdr`
expressions are evaluated only when they are needed; in
addition, the scanner will do its best to make sure that the
expressions are evaluated only once.

    (mac lazy-scanner (a d)
      " Creates a scanner which evaluates the
        given expressions only when 'car and
        'cdr are used on it.
        See also [[lazy-destruct]] [[generate]] "
      `(symeval!lazy-scanner-f (fn () ,a) (fn () ,d)))

`lazy-scanner` simply passes the expressions in two thunks to the
constructing function below.

    (def lazy-scanner-f (af df)
      ; warning!  Not *completely* lazy: it is
      ; possible, in a multithread environment,
      ; for two different threads to execute
      ; a lazy expression simultaneously
      ; we can use semaphore locks of some
      ; sort, but it *might* get bashed by
      ; <base>collect-on (depending on whether
      ; we use dynamic-wind, potentially, but
      ; I'll have to figure out the continuation
      ; guards first)

As you can see from the comment above, lazy scanners might
inadvertently execute the expression multiple times if threads
are involved.  In general you probably should not cause side
effects when using lazy scanners; instead, write functionally.

      (let rv (cons nil nil)

The return value `rv` is the `cons` cell that is packaged into
the `lazy-scanner` type.  We set its `car` and `cdr` to the
thunks that will execute the expressions:

        (= (car rv)
           (fn ()
             (let it (af)
               (= (car rv) (delay it))
               it)))
        (= (cdr rv)
           (fn ()
             (let it (df)
               (= (cdr rv) (delay it))
               it)))

These thunks evaluate the expression, then create new thunks
containing only the evaluated values.  They then replace
themselves, ensuring laziness.

        (annotate 'lazy-scanner-type
          rv)))


Using `lazy-destruct`
---------------------

`lazy-destruct` accepts only one expression.  This expression
should evaluate to a `cons` cell, or other type which overloads
`car` and `cdr`.

This variation is useful if you will end up computing the first
element of the scanner together with the succeeding elements.  In
such a case you may as well just return both the `car` and `cdr`
elements together.
    
    (mac lazy-destruct (c)
      " Creates a scanner from a single expression
        that returns a cons cell or other scanner.
        The expression is evaluated only when
        'car or 'cdr is applied to this scanner.
        See also [[lazy-scanner]] [[generate]] "
      `(symeval!lazy-destruct-f (fn () ,c)))

Again, the pattern is for a macro to expand to an application of
a global function.

    (def lazy-destruct-f (cf)
      (withs (rv (cons nil nil)
              destruct
              (fn ()
                (withs (v (cf)
                        a (car v)
                        d (cdr v))
                  (= (car rv) (delay a))
                  (= (cdr rv) (delay d)))))

The `destruct` function above is a function which executes the
given expression, and then destructures the result.  Since both
the `car` and `cdr` fields become available, the `destruct`
function replaces the fields with delaying thunks for the values.

        (= (car rv)
           (fn ()
             (destruct)
             ((car rv))))
        (= (cdr rv)
           (fn ()
             (destruct)
             ((cdr rv))))

Either of `car` or `cdr` on a `lazy-destruct` scanner will
trigger the evaluation of the given singular expression.  We then
extract the data.

        (annotate 'lazy-scanner-type
          rv)))


Making `map` and friends lazy
-----------------------------

In order to make the sequence generation functions (such as
`keep`, `map`, etc.) themselves lazy, we also include a
definition for `<base>collect-on`.  This definition ensures that
the result is still a lazy scanner.  It affects any algorithms
which use `w/collect-on`.

This function works by setting up two coroutines.  One couroutine
is the caller of the `w/collect-on` algorithm; the other one is
the body of the `w/collect-on` form.

    (defm <base>collect-on ((t seq lazy-scanner-type) bf)
      (point return
        (bf
          (fn (i)
            (point body-return
              (return
                (lazy-scanner
                 i
                 (point new-return
                   (= return new-return)
                   (body-return i)))))))
        ; return might have been reassigned
        (return nil)))

Notice how we abuse the `return` variable.  This is necessary in
order to properly work out what point to return to.


Generating an infinite lazy scanner
-----------------------------------

    (def generate (f i)
      " Creates an infinite lazy sequence from the
        continued application of `f' on `i'.
        See also [[lazy-scanner]] [[lazy-destruct]] "
      (lazy-scanner
        i
        (generate f (f i))))

